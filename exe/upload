#!/usr/bin/env ruby

require 'json'
require 'faraday'
require 'active_support'
require 'active_support/core_ext'

$LOAD_PATH.unshift File.join(File.dirname(__FILE__), '../lib')

def usage
  warn "Usage: upload (appmap-file: 'appmap.json')"
  exit 1
end

appmap_file = ARGV.shift || 'appmap.json'
appmap_data = if appmap_file == '-'
    $stdin.read
  else
    File.read(appmap_file)
  end
appmap = JSON.parse(appmap_data)

# Prune the classMap so that only functions, classes and packages which are referenced
# by some event are retained.
def prune(class_map, events: nil)
  # This proc counts the number of objects in the class map whose type is 'k'
  count = proc do |k, e|
    n = 0
    n += 1 if e['type'] == k
    n += (e['children'] || []).map { |child| count.call(k, child) }.reduce(0, :+)
    n
  end

  warn "Full classMap contains #{class_map.map { |m| count.call('class', m) }.reduce(0, :+)} classes"

  # Prune all the classes which fail a test.
  reject = proc do |list, test|
    list.tap do |_|
      list.each do |item|
        children = item['children']
        next unless children
        reject.call(children, test)
      end
      list.reject!(&test)
    end
  end

  if events
    locations = \
      Set.new(events.select { |e| e['event'] == 'call' }
      .map { |e| [ e['path'], e['lineno'] ].join(':') })

    # Prune all functions which aren't called
    reject.call class_map,
                ->(e) { e['type'] == 'function' && !locations.member?(e['location']) }
  end

  # Prune all empty classes
  reject.call class_map,
              ->(e) { e['type'] == 'class' && (e['children'] || []).empty? }

  # Prune all empty packages
  reject.call class_map,
              ->(e) { e['type'] == 'package' && (e['children'] || []).empty? }

  warn "Pruned classMap contains #{class_map.map { |m| count.call('class', m) }.reduce(0, :+)} classes"

  class_map
end

# If it's a list, upload it as a classMap
if appmap.is_a?(Hash)
  events = appmap['events'] || []
  class_map = appmap['classMap'] || []

  class_map = prune(class_map, events: events)
  appmap = { "classMap": class_map, "events": events }
else
  class_map = prune(appmap)
  appmap = { "classMap": class_map, "events": [] }
end

url = ENV['APPLAND_URL'] || 'https://appland-staging.herokuapp.com'
owner = (ENV['APPLAND_OWNER'] || 1).to_i

upload_file = { owner_id: owner, data: appmap }

conn = Faraday.new(url: url)
response = conn.post do |req|
  req.url '/api/scenarios'
  req.headers['Content-Type'] = 'application/json'
  req.body = JSON.generate(upload_file)
end

unless response.body.blank?
  message = begin
              JSON.parse(response.body)
            rescue StandardError
              JSON::ParserError
            end
end
unless response.success?
  warn 'Upload failed'
  warn message unless message.blank?
  exit 1
end
scenario_id = message['uuid']
puts "Created scenario #{scenario_id}"
system "open #{url}/scenarios/#{scenario_id}"
